[{"content":"apply函数 apply函数是最常用的代替for循环的函数。apply函数可以对矩阵、数据框、数组(二维、多维)，按行或列进行循环计算，对子元素进行迭代，并把子元素以参数传递的形式给自定义的FUN函数中，并以返回计算结果。\n函数定义 apply(X, MARGIN, FUN, ...) 参数列表 X：矩阵、数据框、数组\nMARGIN：按行计算或按按列计算，1表示按行，2表示按列\nFUN: 自定义函数\n…: 自定义参数\n应用 对于矩阵行求和\nx\u0026lt;-matrix(1:12,ncol=3) apply(x,1,sum) ## [1] 15 18 21 24 自定义函数的使用\n# 生成data.frame x \u0026lt;- cbind(x1 = 3, x2 = c(4:1, 2:5)); x ## x1 x2 ## [1,] 3 4 ## [2,] 3 3 ## [3,] 3 2 ## [4,] 3 1 ## [5,] 3 2 ## [6,] 3 3 ## [7,] 3 4 ## [8,] 3 5 # 自定义函数myFUN，第一个参数x为数据 # 第二、三个参数为自定义参数，可以通过apply的\u0026#39;...\u0026#39;进行传入。 myFUN\u0026lt;- function(x, c1, c2) { c(sum(x[c1],1), mean(x[c2])) } # 把数据框按行做循环，每行分别传递给myFUN函数，设置c1,c2对应myFUN的第二、三个参数 apply(x,1,myFUN,c1=\u0026#39;x1\u0026#39;,c2=c(\u0026#39;x1\u0026#39;,\u0026#39;x2\u0026#39;)) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 4.0 4 4.0 4 4.0 4 4.0 4 ## [2,] 3.5 3 2.5 2 2.5 3 3.5 4 lapply函数 lapply函数是一个最基础循环操作函数之一。主要操作对象是list、data.frame，并返回和X长度同样的list结构作为结果集。\n函数定义 lapply(X, FUN, ...) 参数列表 X：矩阵、数据框、数组 FUN: 自定义函数 …: 自定义参数\n应用 对list进行操作\nx \u0026lt;- list(a = c(1:3), b = c(4:6), d = c(10:20)) lapply(x, sum) ## $a ## [1] 6 ## ## $b ## [1] 15 ## ## $d ## [1] 165 对data.frame进行操作\nx \u0026lt;- data.frame(x1=3, x2=c(2:1,4:5)) lapply(x, sum) ## $x1 ## [1] 12 ## ## $x2 ## [1] 12 sapply函数 sapply函数是一个简化版的lapply，sapply增加了2个参数simplify和USE.NAMES，主要就是让输出看起来更友好，返回值为向量，而不是list对象。\n函数定义 sapply(X, FUN, ..., simplify=TRUE, USE.NAMES = TRUE) 参数列表 X：矩阵、数据框、数组 FUN: 自定义函数 …: 自定义参数 simplify：是否数组化，当值是array时，输出结果按数组进行分组 USE.NAMES：如果X为字符串，TRUE设置字符串为数据名，FALSE不设置\n应用 对上面的数据框x进行操作：\nsapply(x, sum) ## x1 x2 ## 12 12 class(lapply(x, sum)) # lapply返回list，sapply返回vector ## [1] \u0026#34;list\u0026#34; class(sapply(x, sum)) ## [1] \u0026#34;numeric\u0026#34; vapply函数 vapply类似于sapply，提供了FUN.VALUE参数，用来控制返回值的行名。\n函数定义 vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE) 参数列表 X：矩阵、数据框、数组 FUN: 自定义函数 FUN.VALUE：定义返回值的行名 …: 自定义参数 USE.NAMES：如果X为字符串，TRUE设置字符串为数据名，FALSE不设置\n应用 x \u0026lt;- data.frame(cbind(x1=3, x2=c(2:1,4:5))) vapply(x,cumsum,FUN.VALUE = c(\u0026#39;a\u0026#39;=0,\u0026#39;b\u0026#39;=0,\u0026#39;c\u0026#39;=0,\u0026#39;d\u0026#39;=0)) #注意FUN.VALUE的用法 ## x1 x2 ## a 3 2 ## b 6 3 ## c 9 7 ## d 12 12 mapply函数 相当于多参数版本的 sapply。第一次计算传入各组向量的第一个元素到FUN，进行结算得到结果；第二次传入各组向量的第二个元素，得到结果；第三次传入各组向量的第三个元素…以此类推。\n函数定义 mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE,USE.NAMES = TRUE) 参数列表 主要使用的参数有三个 FUN: 自定义函数 FUN.VALUE：定义返回值的行名 …: 自定义参数\n应用 mapply(rep, 1:4, 4:1) #每一组参数都是对应的 ## [[1]] ## [1] 1 1 1 1 ## ## [[2]] ## [1] 2 2 2 ## ## [[3]] ## [1] 3 3 ## ## [[4]] ## [1] 4 tapply函数 tapply用于分组的循环计算，通过INDEX参数可以把数据集X进行分组，相当于group by的操作。\n函数定义 tapply(X, INDEX, FUN = NULL, ..., simplify = TRUE) 参数列表 X：向量 INDEX: 分组索引 FUN: 自定义函数 …: 接收多个数据 simplify：是否数组化，当值array时，输出结果按数组进行分组\n应用 # 对样本分组计数 tapply(warpbreaks$breaks, warpbreaks[,-1], sum) ## tension ## wool L M H ## A 401 216 221 ## B 254 259 169 ","permalink":"https://jeason.netlify.app/en/posts/tech/apply/","summary":"apply函数 apply函数是最常用的代替for循环的函数。apply函数可以对矩阵、数据框、数组(二维、多维)，按行或列进行循环计算，对子元素进行迭代，并把子元素以参数传递的形式给自定义的FUN函数中，并以返回计算结果。 函数定义 apply(X, MARGIN, FUN, ...) 参数列表 X：矩阵、数据框、数组 MARGIN","title":"浅识apply家族"},{"content":"Single cell 单细胞测序-最佳的分析Pipeline Single-cell best practices Orchestrating Single-Cell Analysis with Bioconductor Best Practices for Spatial Transcriptomics Analysis with Bioconductor Analysis of single cell RNA-seq data RNA-seq analysis 该教程比较详细，适合初学者。\nGuide to RNA-seq analysis Bioinformatics Practical Computing and Bioinformatics for Conservation and Evolutionary Genomics Bioinformatics Tutorial Data Visualization Fundamentals of Data Visualization Data visualisation using R, for researchers who don’t use R ggplot2: Elegant Graphics for Data Analysis (3e) Data Science R for Data Science (2e) 数据科学中的 R 语言 Machine learning Tidy Modeling with R The caret Package Caret Package – A Practical Guide to Machine Learning in R AI-EDU R Packages R Packages (2e) ","permalink":"https://jeason.netlify.app/en/posts/read/bioinfo_resource/","summary":"Single cell 单细胞测序-最佳的分析Pipeline Single-cell best practices Orchestrating Single-Cell Analysis with Bioconductor Best Practices for Spatial Transcriptomics Analysis with Bioconductor Analysis of single cell RNA-seq data RNA-seq analysis 该教程比较详细，适合初学者。 Guide to RNA-seq analysis Bioinformatics Practical Computing and Bioinformatics for Conservation and Evolutionary Genomics Bioinformatics Tutorial Data Visualization Fundamentals of Data Visualization Data visualisation using R, for researchers who don’t use R ggplot2: Elegant Graphics for Data Analysis (3e) Data Science R for Data Science (2e) 数据科学中的 R 语言 Machine learning Tidy Modeling with R The caret Package Caret Package – A Practical Guide to Machine Learning in R AI-EDU R","title":"生物信息学学习资源"},{"content":"背景 通常在对物种做GO富集分析时，我们会遇到2种情况模式物种 \u0026amp; 非模式物种；针对模式物种专门的Orgdb包，但是目前针对模式物种的包只有20种,针对非模式职位另一种解决方案是通过AnnotationForge包来创建Orgdb包，本节来介绍如何构建非模式物种的Orgdb来做GO富集分析\n1.准备注释文件 首先需要获取物种对应的注释文件（无论蛋白组还是基因组）\n注释文件可以通过eggnog网站上传参考序列文件注释得到(eggnog-mapper也可注释)\n注释之后会生成以下文件：\n[project_name].emapper.hmm_hits: 记录每个用于搜索序列对应的所有的显著性的eggNOG Orthologous Groups(OG). 所有标记为\u0026quot;-\u0026ldquo;则表明该序列未找到可能的OG [project_name].emapper.seed_orthologs: 记录每个用于搜索序列对的的最佳的OG，也就是[project_name].emapper.hmm_hits里选择得分最高的结果。之后会从eggNOG中提取更精细的直系同源关系(orthology relationships) [project_name].emapper.annotations: 该文件提供了最终的注释结果。大部分需要的内容都可以通过写脚本从从提取。 [project_name].emapper.annotations中主要列对应的记录如下：\nquery_name: 检索的基因名或者其他ID sedd_ortholog: eggNOG中最佳的蛋白匹配 evalue: 最佳匹配的e-value score: 最佳匹配的bit-score Preferred_name: 预测的基因名，特别指的是类似AP2有一定含义的基因名，而不是AT2G17950这类编号 GOs: 推测的GO的词条， 未必最新 KEGG_KO: 推测的KEGG KO词条， 未必最新 BiGG_Reactions: BiGG代谢反应的预测结果 2.安装AnnotationForge包 if (!requireNamespace(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) BiocManager::install(\u0026#34;AnnotationForge\u0026#34;) 3.导入数据 从准备的注释文件导入注释信息，并提取必要的列用于构建库\nemapper \u0026lt;- read.delim(\u0026#34;emapper.annotations.xls\u0026#34;) %\u0026gt;% dplyr::select(GID=query_name,Gene_Symbol=Preferred_name, GO=GOs,KO=KEGG_ko,Pathway =KEGG_Pathway, OG =X.3,Gene_Name =X.4) gene_info \u0026lt;- dplyr::select(emapper,GID,Gene_Name) %\u0026gt;% dplyr::filter(!is.na(Gene_Name)) gene2go \u0026lt;- dplyr::select(emapper,GID,GO) %\u0026gt;% separate_rows(GO, sep = \u0026#39;,\u0026#39;, convert = F) %\u0026gt;% dplyr::filter(GO!=\u0026#34;\u0026#34;,!is.na(GO)) %\u0026gt;% mutate(EVIDENCE = \u0026#39;A\u0026#39;) 4.构建0rgdb包 AnnotationForge::makeOrgPackage(gene_info=gene_info, go=gene2go, maintainer=\u0026#39;test\u0026lt;youremail@gmail.com\u0026gt;\u0026#39;, author=\u0026#39;name\u0026#39;, version=\u0026#34;0.1\u0026#34; , outputDir=\u0026#34;.\u0026#34;, tax_id=\u0026#34;59729\u0026#34;, genus=\u0026#34;M\u0026#34;, species=\u0026#34;A\u0026#34;, goTable = \u0026#34;go\u0026#34;) 5.安装R包 可以直接从文件夹进行安装，也可以构造之后安装\ninstall.packages(\u0026#39;path/to/dir\u0026#39;, repos = NULL, type = \u0026#39;source) ","permalink":"https://jeason.netlify.app/en/posts/tech/annotationforge/","summary":"背景 通常在对物种做GO富集分析时，我们会遇到2种情况模式物种 \u0026amp; 非模式物种；针对模式物种专门的Orgdb包，但是目前针对模式物种的包只有20种,针对非模式职位另一种解决方案是通过AnnotationForge包来创建Orgdb包，本节来介绍如何构建非模式物种的Orgdb来做GO富集","title":"AnnotationForge包构建非模式物种Orgdb包"},{"content":"安装 根据电脑版本下载对应aspera connect server，下载地址：https://www.ibm.com/products/aspera/downloads\ncd ./download wget http://download.asperasoft.com/download/sw/connect/3.7.4/aspera-connect-3.7.4.147727-linux-64.tar.gz 下载获得的是shell脚本，解压安装\ntar zxf aspera-connect-3.7.4.147727-linux-64.tar.gz bash aspera-connect-3.7.4.147727-linux-64.sh 安装后找到home目录下的会有一个.aspera目录，里边包含密钥等信息，可以将其添加入环境变量中\n在.aspera的目录，有两个文件比较重要: 一个是ascp的可执行文件~/.aspera/connect/bin/ascp，另一个ascp的密钥文件~/.aspera/connect/etc/asperaweb_id_dsa.putty,可以把密钥备份到home目录当中\ncd ~ echo \u0026#39;PATH=$PATH:/home/jeason/.aspera/connect/bin/\u0026#39; \u0026gt;\u0026gt; ~/.bashrc cp ~/.aspera/connect/etc/asperaweb_id_dsa.putty ~/ source .bashrc 重新source配置文件生效\n使用ascp --help参看命令参数\n常见参数：\n-v verbose mode 唠叨模式，能让你实时知道程序在干啥，方便查错。 -T 取消加密，否则有时候数据下载不了 。 -i 提供私钥文件的地址，我也不知道干嘛的，反正不能少，地址一般是~/.aspera/connect/etc中的asperaweb_id_dsa.openssh文件 -l 设置最大传输速度，一般200m到500m，如果不设置，反而速度会比较低，可能有个较低的默认值 -k 断点续传，一般设置为值1 下载sra数据 ascp -T -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh -k 1 -l 200m anonftp@ftp-private.ncbi.nlm.nih.gov:/sra/sra-instant/reads/ByRun/sra/SRR/SRR620/SRR6208854/SRR6208854.sra ./ SRA数据库下载：首先记住，数据的存放地址是ftp-private.ncbi.nlm.nih.gov，SRA在Aspera的用户名是anonftp\nAspera批量下载SRA文件 很多时候需要同时下载多个SRA文件，ascp命令提供参数--file-list，用于批量下载SRA文件。\n可以将下载列表写入sra.txt文件中，然后进行批量下载\n/sra/sra-instant/reads/ByRun/sra/SRR/SRR623/SRR6232298/SRR6232298.sra /sra/sra-instant/reads/ByRun/sra/SRR/SRR623/SRR6232299/SRR6232299.sra ascp -T -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh -k 1 -l 200m --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp --file-list ~/sra.txt ./ asprea同样可以下载ENA的数据，ENA在Aspera的用户名是era-fasp，数据的存放地址是fasp.sra.ebi.ac.uk\n报错 有时会遇到以下报错：\nascp: Failed to open TCP connection for SSH, exiting. Session Stop (Error: Failed to open TCP connection for SSH) 官方回答：\nOn many Linux systems the default firewall can be configured with iptables. You will have to allow all incoming and outgoing traffic on UDP port 33001 (or whatever your Aspera UDP port is), which you can do with the following commands:\n使用如下命令进行操作：\niptables -I INPUT -p tcp --dport 33001 -j ACCEPT iptables -I OUTPUT -p tcp --dport 33001 -j ACCEPT ","permalink":"https://jeason.netlify.app/en/posts/tech/aspera/","summary":"安装 根据电脑版本下载对应aspera connect server，下载地址：https://www.ibm.com/products/aspera/downloads cd ./download wget http://download.asperasoft.com/download/sw/connect/3.7.4/aspera-connect-3.7.4.147727-linux-64.tar.gz 下载获得的是shell脚本，解压安装 tar zxf aspera-connect-3.7.4.147727-linux-64.tar.gz bash aspera-connect-3.7.4.147727-linux-64.sh 安装后找到home目录下的会有一个.aspera目录，里边包含密钥等信息，","title":"Aspera的安装与使用"},{"content":"数据结构 R 语言的基础数据结构可以按照维度来划分(1 维、 2 维\u0026hellip;n 维)；也可以按照它们所包含的数据类型是否相同来划分。 这样就产生了五种数据类型，它们是数据分析中最常用的：\nHomogeneous Heterogeneous 1d Atomic vector List 2d Matrix Data frame nd Array 向量（vector） 向量包括：原子向量 （Atomic vector） 和列表 （List）。兩者都属于一维数据， 两者的区别在于： 原子向量中的所有元素都必须是相同的类型；而列表中的元素可以是不同的类型\nis.vector()并不能测试一个对象是不是向量。 相反，仅当对象是除了名字以外，不包含其它属性时，它才返回 TRUE。 所以，请使用 is.atomic(x) || is.list(x) 来测试一个对象是不是向量。\n向量具有三个共同属性：\n类型， typeof()，它是什么 长度， length()，它包含有多少元素 属性， attributes()，额外的任意元数据 原子向量 (Atomic vector) 原子向量类型：逻辑类型 (logical)、 整数类型 (integer)、 双精度数值类型 (double)、 字符类型 (character)、 复数类型 (complex)、 raw类型。 缺失值用 NA 表示，是一个长度为1的逻辑向量，NA可根据所处整体环境强制转换成正确的类型，或者使用 NA_real_(双精度浮点数向量)、 NA_integer_ 和 NA_character_ 来创建一系列确定类型的 NA typeof 确定具体的数据类型，is开头的函数（如：is.integer）来确定是否属于某一特定类型 is.atomic() 是检测原子向量最通用的 强制转换：一个原子向量中的所有元素都必须是相同的类型。 所以，当你试图合并不同类型的数据时，将向最灵活的类型进行强制转换。 以灵活程度排序，从小到大依次为：逻辑、 整数、双精度浮点数和字符。 如果转换遇到歧义，则需要使用 as.character()、 as.double()、 as.integer()或者 as.logical()等函数，进行明确的强制转换。 列表(List) c()可以将几个向量合并成一个。 如果原子向量和列表同时存在，那么在合并之前， c()会将原子向量强制转换成列表\nx \u0026lt;- list(list(1, 2), c(3, 4)) y \u0026lt;- c(list(1, 2), c(3, 4)) str(x) #\u0026gt; List of 2 #\u0026gt; $ :List of 2 #\u0026gt; ..$ : num 1 #\u0026gt; ..$ : num 2 #\u0026gt; $ : num [1:2] 3 4 str(y) #\u0026gt; List of 4 #\u0026gt; $ : num 1 #\u0026gt; $ : num 2 #\u0026gt; $ : num 3 #\u0026gt; $ : num 4 列表用来建立 R 语言中的许多更加复杂的数据结构。 比如， 数据框和其他复杂对象\nis.list(mtcars) #\u0026gt; [1] TRUE 这里说明一点：data.frame是比list更为复杂的数据结构\n属性(Attributes) 所有的对象都可以拥有任意多个附加属性， 附加属性用来存取与该对象相关的元数据。 属性可以看做是已命名的列表(带有不重复的名字)。 属性可以使用 attr()函数一个一个的访问，也可以使用 attributes()函数一次性访问。\ny \u0026lt;- 1:10 attr(y, \u0026#34;my_attribute\u0026#34;) \u0026lt;- \u0026#34;This is a vector\u0026#34; attr(y, \u0026#34;alpha\u0026#34;) \u0026lt;- \u0026#34;This is a vector\u0026#34; attr(y, \u0026#34;my_attribute\u0026#34;) #\u0026gt; [1] \u0026#34;This is a vector\u0026#34; attributes(y) #\u0026gt; $my_attribute #\u0026gt; [1] \u0026#34;This is a vector\u0026#34; #\u0026gt; #\u0026gt; $alpha #\u0026gt; [1] \u0026#34;This is a vector\u0026#34; attr(y, \u0026#34;my_attribute\u0026#34;) \u0026lt;- \u0026#34;alpha\u0026#34; attributes(y) #\u0026gt; $my_attribute #\u0026gt; [1] \u0026#34;alpha\u0026#34; #\u0026gt; #\u0026gt; $alpha #\u0026gt; [1] \u0026#34;This is a vector\u0026#34; structure() 函数返回一个带有属性的对象， 也可以用来修改属性\nstructure(y, alpha = \u0026#34;alpha\u0026#34;) #\u0026gt; [1] 1 2 3 4 5 6 7 8 9 10 #\u0026gt; attr(,\u0026#34;my_attribute\u0026#34;) #\u0026gt; [1] \u0026#34;alpha\u0026#34; #\u0026gt; attr(,\u0026#34;alpha\u0026#34;) #\u0026gt; [1] \u0026#34;alpha\u0026#34; 默认情况下，当修改向量时，数据的大多数属性会丢失，但有三种重要的属性不会丢失：名字(name)，维度(dimension)，类(class)\n三个特殊属性需要使用特定函数names(x)、 class(x)和 dim(x) 访问，而不是 attr(x, \u0026quot;names\u0026quot;)、 attr(x, \u0026quot;class\u0026quot;) 和 attr(x, \u0026quot;dim\u0026quot;)\n数据框(data frame) 数据框是由等长向量构成的列表。 它也是二维结构，所以它具有矩阵和列表双重属性。也就是说，数据框拥有 names()、 colnames()和 rownames()，尽管 names()和 colnames()对数据框来说是一样的。 数据框的 length()是列表的长度，所以和 ncol()相同； nrow()则得到行数。\n由于数据框是一个包含向量的列表，所以数据框的某个是列表类型是有可能的：\ndf \u0026lt;- data.frame(x = 1:3) df$y \u0026lt;- list(1:2, 1:3, 1:4) df #\u0026gt; x y #\u0026gt; 1 1 1, 2 #\u0026gt; 2 2 1, 2, 3 #\u0026gt; 3 3 1, 2, 3, 4 当把列表传入 data.frame()函数时，该函数将试图把列表的每一个元素都放到单独的一列中。一种绕开的方法是使用 I()函数，它使得 data.frame()把列表看成一个整体单元\nR中的对象 S3对象 S3 对象是由原子向量、数组和列表组成的，所以你可以使用上面描述的技术对 S3 对象进行取子集操作。 你可以通过 str()函数获得的它们的结构信息。\nS4对象 对 S4 对象来说，有另外两种取子集操作符: @(相当于$)和 slot()(相当于[[)。 @比$更加严格，如果槽(slot)不存在，那么它会返回错误。\nAdvanced R\n","permalink":"https://jeason.netlify.app/en/posts/tech/advancer/","summary":"数据结构 R 语言的基础数据结构可以按照维度来划分(1 维、 2 维\u0026hellip;n 维)；也可以按照它们所包含的数据类型是否相同来划分。 这样就产生了五种数据类型，它们是数据分析中最常用的： Homogeneous Heterogeneous 1d Atomic vector List 2d Matrix Data frame nd Array 向量（vector） 向量包括：原子向量 （Atomic vector） 和列表 （L","title":"R语言高级程序设计"},{"content":"typeof class mode storage.mode 的区别 class 根据 class 函数的帮助文档可知：\nR possesses a simple generic function mechanism which can be used for an object-oriented style of programming. Method dispatch takes place based on the class of the first argument to the generic function.\nclass 给出的是一个对象的抽象类型（也可以理解为对象的特定属性），主要针对的是R中的泛型函数，用于泛型函数的参数识别\n可以这样理解：R是一种基于对象(object)的语言，R中的所有内容都是对象，每个对象都有不同的属性（attribute），而对象最重要的属性是他们的类型（class），决定了对象在R中可以进行什么样的操作\n正常情况下，对于一般的R对象，如果没有类属性（class），那么它肯定有一个隐式的类属性（class），而隐式属性是类似于 mode 的结果\na \u0026lt;- 1 # numeric class(a) # 显示隐式类属性 [1] \u0026#34;numeric\u0026#34; attributes(a) # attributes查看属性，不能看到隐式类属性 NULL a \u0026lt;- structure(a, class = \u0026#34;a\u0026#34;) # 赋予显式类属性 class(a) [1] \u0026#34;a\u0026#34; attributes(a) # attributes查看属性，可以看到显式类属性 $class [1] \u0026#34;a\u0026#34; 注意：NULL 对象是没有属性的，并且也不能对它赋予任何属性\ninherits 函数用来判断对象是否具有某一类属性（class）\n基本类型情况 对于单个值或者向量，class 返回隐式属性（与 mode 结果一致）；如：numeric，character 对于矩阵，数组，日期，因子，class 返回matrix，array，Date，factor 对于数据框，class 返回data.frame 对于列表，class 返回list mode storage.mode typeof mode、 storage.mode、 typeof 是同一类别的函数，它们识别的是对象在内存中的存储类型，即返回的是R中的基本数据类型\nR中的基本数据类型：\u0026ldquo;logical\u0026rdquo;, \u0026ldquo;integer\u0026rdquo;, \u0026ldquo;double\u0026rdquo;, \u0026ldquo;complex\u0026rdquo;, \u0026ldquo;raw\u0026rdquo;,\u0026ldquo;character\u0026rdquo;, \u0026ldquo;list\u0026rdquo;, \u0026ldquo;expression\u0026rdquo;, \u0026ldquo;name\u0026rdquo;, \u0026ldquo;symbol\u0026rdquo; 和 \u0026ldquo;function\u0026rdquo;\n对于 mode、 storage.mode、 typeof 三个函数来说，mode 是比较旧的版本，typeof 是更新的、也是更细的一种形式；三个函数检测的精细程度为：mode \u0026gt; storage.mode \u0026gt; typeof\nmode(1:5) # numeric storage.mode(1:5) # integer typeof(1:5) # integer mode(`+`) # function storage.mode(`+`) # function typeof(`+`) # builtin ","permalink":"https://jeason.netlify.app/en/posts/tech/typeof/","summary":"typeof class mode storage.mode 的区别 class 根据 class 函数的帮助文档可知： R possesses a simple generic function mechanism which can be used for an object-oriented style of programming. Method dispatch takes place based on the class of the first argument to the generic function. class 给出的是一个对象的抽象类型（也可以理解为对象的特定属性），主要针对的是R中的泛型函数，用于泛型函数的参数识别 可以这样理解：R是一种基于对象(object)的语言，R中的所","title":"typeof class mode storage.mode 的区别"}]