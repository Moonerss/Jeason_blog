[{"content":"背景 通常在对物种做GO富集分析时，我们会遇到2种情况模式物种 \u0026amp; 非模式物种；针对模式物种专门的Orgdb包，但是目前针对模式物种的包只有20种,针对非模式职位另一种解决方案是通过AnnotationForge包来创建Orgdb包，本节来介绍如何构建非模式物种的Orgdb来做GO富集分析\n1.准备注释文件 首先需要获取物种对应的注释文件（无论蛋白组还是基因组）\n注释文件可以通过eggnog网站上传参考序列文件注释得到(eggnog-mapper也可注释)\n注释之后会生成以下文件：\n[project_name].emapper.hmm_hits: 记录每个用于搜索序列对应的所有的显著性的eggNOG Orthologous Groups(OG). 所有标记为\u0026quot;-\u0026ldquo;则表明该序列未找到可能的OG [project_name].emapper.seed_orthologs: 记录每个用于搜索序列对的的最佳的OG，也就是[project_name].emapper.hmm_hits里选择得分最高的结果。之后会从eggNOG中提取更精细的直系同源关系(orthology relationships) [project_name].emapper.annotations: 该文件提供了最终的注释结果。大部分需要的内容都可以通过写脚本从从提取。 [project_name].emapper.annotations中主要列对应的记录如下：\nquery_name: 检索的基因名或者其他ID sedd_ortholog: eggNOG中最佳的蛋白匹配 evalue: 最佳匹配的e-value score: 最佳匹配的bit-score Preferred_name: 预测的基因名，特别指的是类似AP2有一定含义的基因名，而不是AT2G17950这类编号 GOs: 推测的GO的词条， 未必最新 KEGG_KO: 推测的KEGG KO词条， 未必最新 BiGG_Reactions: BiGG代谢反应的预测结果 2.安装AnnotationForge包 if (!requireNamespace(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) BiocManager::install(\u0026#34;AnnotationForge\u0026#34;) 3.导入数据 从准备的注释文件导入注释信息，并提取必要的列用于构建库\nemapper \u0026lt;- read.delim(\u0026#34;emapper.annotations.xls\u0026#34;) %\u0026gt;% dplyr::select(GID=query_name,Gene_Symbol=Preferred_name, GO=GOs,KO=KEGG_ko,Pathway =KEGG_Pathway, OG =X.3,Gene_Name =X.4) gene_info \u0026lt;- dplyr::select(emapper,GID,Gene_Name) %\u0026gt;% dplyr::filter(!is.na(Gene_Name)) gene2go \u0026lt;- dplyr::select(emapper,GID,GO) %\u0026gt;% separate_rows(GO, sep = \u0026#39;,\u0026#39;, convert = F) %\u0026gt;% dplyr::filter(GO!=\u0026#34;\u0026#34;,!is.na(GO)) %\u0026gt;% mutate(EVIDENCE = \u0026#39;A\u0026#39;) 4.构建0rgdb包 AnnotationForge::makeOrgPackage(gene_info=gene_info, go=gene2go, maintainer=\u0026#39;test\u0026lt;youremail@gmail.com\u0026gt;\u0026#39;, author=\u0026#39;name\u0026#39;, version=\u0026#34;0.1\u0026#34; , outputDir=\u0026#34;.\u0026#34;, tax_id=\u0026#34;59729\u0026#34;, genus=\u0026#34;M\u0026#34;, species=\u0026#34;A\u0026#34;, goTable = \u0026#34;go\u0026#34;) 5.安装R包 可以直接从文件夹进行安装，也可以构造之后安装\ninstall.packages(\u0026#39;path/to/dir\u0026#39;, repos = NULL, type = \u0026#39;source) ","permalink":"https://example.org/en/posts/tech/annotationforge/","summary":"背景 通常在对物种做GO富集分析时，我们会遇到2种情况模式物种 \u0026amp; 非模式物种；针对模式物种专门的Orgdb包，但是目前针对模式物种的包只有20种,针对非模式职位另一种解决方案是通过AnnotationForge包来创建Orgdb包，本节来介绍如何构建非模式物种的Orgdb来做GO富集","title":"AnnotationForge包构建非模式物种Orgdb包"},{"content":"数据结构 R 语言的基础数据结构可以按照维度来划分(1 维、 2 维\u0026hellip;n 维)；也可以按照它们所包含的数据类型是否相同来划分。 这样就产生了五种数据类型，它们是数据分析中最常用的：\nHomogeneous Heterogeneous 1d Atomic vector List 2d Matrix Data frame nd Array 向量（vector） 向量包括：原子向量 （Atomic vector） 和列表 （List）。兩者都属于一维数据， 两者的区别在于： 原子向量中的所有元素都必须是相同的类型；而列表中的元素可以是不同的类型\nis.vector()并不能测试一个对象是不是向量。 相反，仅当对象是除了名字以外，不包含其它属性时，它才返回 TRUE。 所以，请使用 is.atomic(x) || is.list(x) 来测试一个对象是不是向量。\n向量具有三个共同属性：\n类型， typeof()，它是什么 长度， length()，它包含有多少元素 属性， attributes()，额外的任意元数据 原子向量 (Atomic vector) 原子向量类型：逻辑类型 (logical)、 整数类型 (integer)、 双精度数值类型 (double)、 字符类型 (character)、 复数类型 (complex)、 raw类型。 缺失值用 NA 表示，是一个长度为1的逻辑向量，NA可根据所处整体环境强制转换成正确的类型，或者使用 NA_real_(双精度浮点数向量)、 NA_integer_ 和 NA_character_ 来创建一系列确定类型的 NA typeof 确定具体的数据类型，is开头的函数（如：is.integer）来确定是否属于某一特定类型 is.atomic() 是检测原子向量最通用的 强制转换：一个原子向量中的所有元素都必须是相同的类型。 所以，当你试图合并不同类型的数据时，将向最灵活的类型进行强制转换。 以灵活程度排序，从小到大依次为：逻辑、 整数、双精度浮点数和字符。 如果转换遇到歧义，则需要使用 as.character()、 as.double()、 as.integer()或者 as.logical()等函数，进行明确的强制转换。 列表(List) c()可以将几个向量合并成一个。 如果原子向量和列表同时存在，那么在合并之前， c()会将原子向量强制转换成列表\nx \u0026lt;- list(list(1, 2), c(3, 4)) y \u0026lt;- c(list(1, 2), c(3, 4)) str(x) #\u0026gt; List of 2 #\u0026gt; $ :List of 2 #\u0026gt; ..$ : num 1 #\u0026gt; ..$ : num 2 #\u0026gt; $ : num [1:2] 3 4 str(y) #\u0026gt; List of 4 #\u0026gt; $ : num 1 #\u0026gt; $ : num 2 #\u0026gt; $ : num 3 #\u0026gt; $ : num 4 列表用来建立 R 语言中的许多更加复杂的数据结构。 比如， 数据框和其他复杂对象\nis.list(mtcars) #\u0026gt; [1] TRUE 这里说明一点：data.frame是比list更为复杂的数据结构\n属性(Attributes) 所有的对象都可以拥有任意多个附加属性， 附加属性用来存取与该对象相关的元数据。 属性可以看做是已命名的列表(带有不重复的名字)。 属性可以使用 attr()函数一个一个的访问，也可以使用 attributes()函数一次性访问。\ny \u0026lt;- 1:10 attr(y, \u0026#34;my_attribute\u0026#34;) \u0026lt;- \u0026#34;This is a vector\u0026#34; attr(y, \u0026#34;alpha\u0026#34;) \u0026lt;- \u0026#34;This is a vector\u0026#34; attr(y, \u0026#34;my_attribute\u0026#34;) #\u0026gt; [1] \u0026#34;This is a vector\u0026#34; attributes(y) #\u0026gt; $my_attribute #\u0026gt; [1] \u0026#34;This is a vector\u0026#34; #\u0026gt; #\u0026gt; $alpha #\u0026gt; [1] \u0026#34;This is a vector\u0026#34; attr(y, \u0026#34;my_attribute\u0026#34;) \u0026lt;- \u0026#34;alpha\u0026#34; attributes(y) #\u0026gt; $my_attribute #\u0026gt; [1] \u0026#34;alpha\u0026#34; #\u0026gt; #\u0026gt; $alpha #\u0026gt; [1] \u0026#34;This is a vector\u0026#34; structure() 函数返回一个带有属性的对象， 也可以用来修改属性\nstructure(y, alpha = \u0026#34;alpha\u0026#34;) #\u0026gt; [1] 1 2 3 4 5 6 7 8 9 10 #\u0026gt; attr(,\u0026#34;my_attribute\u0026#34;) #\u0026gt; [1] \u0026#34;alpha\u0026#34; #\u0026gt; attr(,\u0026#34;alpha\u0026#34;) #\u0026gt; [1] \u0026#34;alpha\u0026#34; 默认情况下，当修改向量时，数据的大多数属性会丢失，但有三种重要的属性不会丢失：名字(name)，维度(dimension)，类(class)\n三个特殊属性需要使用特定函数names(x)、 class(x)和 dim(x) 访问，而不是 attr(x, \u0026quot;names\u0026quot;)、 attr(x, \u0026quot;class\u0026quot;) 和 attr(x, \u0026quot;dim\u0026quot;)\n数据框(data frame) 数据框是由等长向量构成的列表。 它也是二维结构，所以它具有矩阵和列表双重属性。也就是说，数据框拥有 names()、 colnames()和 rownames()，尽管 names()和 colnames()对数据框来说是一样的。 数据框的 length()是列表的长度，所以和 ncol()相同； nrow()则得到行数。\n由于数据框是一个包含向量的列表，所以数据框的某个是列表类型是有可能的：\ndf \u0026lt;- data.frame(x = 1:3) df$y \u0026lt;- list(1:2, 1:3, 1:4) df #\u0026gt; x y #\u0026gt; 1 1 1, 2 #\u0026gt; 2 2 1, 2, 3 #\u0026gt; 3 3 1, 2, 3, 4 当把列表传入 data.frame()函数时，该函数将试图把列表的每一个元素都放到单独的一列中。一种绕开的方法是使用 I()函数，它使得 data.frame()把列表看成一个整体单元\nR中的对象 S3对象 S3 对象是由原子向量、数组和列表组成的，所以你可以使用上面描述的技术对 S3 对象进行取子集操作。 你可以通过 str()函数获得的它们的结构信息。\nS4对象 对 S4 对象来说，有另外两种取子集操作符: @(相当于$)和 slot()(相当于[[)。 @比$更加严格，如果槽(slot)不存在，那么它会返回错误。\nAdvanced R\n","permalink":"https://example.org/en/posts/tech/advancer/","summary":"数据结构 R 语言的基础数据结构可以按照维度来划分(1 维、 2 维\u0026hellip;n 维)；也可以按照它们所包含的数据类型是否相同来划分。 这样就产生了五种数据类型，它们是数据分析中最常用的： Homogeneous Heterogeneous 1d Atomic vector List 2d Matrix Data frame nd Array 向量（vector） 向量包括：原子向量 （Atomic vector） 和列表 （L","title":"R语言高级程序设计"}]